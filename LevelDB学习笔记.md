搜搜：为什么，可以看到所以有疑惑的地方

# 概述

**levelDB特点**：
1. KV系统，不狂吃内存，将大部分数据存储到磁盘上
2. 根据key值，有序存储，用户可自定义比较函数，按此顺序存储
3. 接口简单。写记录、读记录、删除记录。支持多条操作的原子批量操作
4. 具有快照功能。<font color='red'>为什么捏</font>:快照功能可以使读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。怎么就做到了能
5. 支持数据压缩，可以增快IO效率、
6. 写操作大大快于读操作，顺序读写操作，大大快于随机读写操作。
7. 随机写 40万条/s，随机读6万条/s

# 整理架构
就是说需要了解：
1. LevelDB存储的数据在内存和磁盘中是如何分布的，处于什么状态
2. 如何写和如何读，即接口内的内部操作
3. 系统崩溃是如何恢复

**主题构成元素**：
1. 内存中的 Memtable、Immutable Memtable
2. 磁盘中的文件：Current文件、Manifest文件，log文件，SSTable文件

**具体存储过程**
1. 先写log，在插入内存中的MemTable，一次写操作只涉及一次磁盘写入和一次内存写入，所以速度快，也能防止崩溃是内存的的数据没有及时dump到内存中而丢失。(可以从内存中恢复)
2. 内存中的MemeTable占用到一定程度后，会导出到外村文件中，生成新的Log文件和Immutable MemTable（由memtable生成，且是只读的，无法写入和删除）
3. 导出这一过程完成后，新来的数据会记录到新的Log和Memtable，重复第1步
4. 并且LeveDB会将Immutable中的数据导到磁盘（即内存-->外村-->磁盘），形成 新的SSTable文件（所有的.sst文件称为SSTable文件，注意关系）。可称为Compaction过程
5. SSTable的所有文件是一种层级结构，level0，level1...,所以称为LevelDB（考点），文件后缀是.sst

.sst文件中数据是按Key有序的。Level0中，一个.sst文件中的数据的key，可能和另一个.sst的key重叠，但是其他的层Level L的.sst文件是不会的，后面很多操作的差异都是这个原因导致

**Manifest**：存储.sst文件的信息,如最大的Key和最小的key，属于哪个level等等

**current**：manifest文件会不断更新，current就记录当前manifest文件名，只有一行信息

## log文件的结构

log文件被切割成32K单位的物理Block，每次读取的单位以一个Block作为基本的读取单位。
从物理布局来讲，一个log文件就是有连续的32K大小Block构成的。

在应用的视野里是看不到这些Block的，应用能看到的时候一系列的Key：Value对。在LevelDB还会对每条key:value对增加一些管理信息，如下：